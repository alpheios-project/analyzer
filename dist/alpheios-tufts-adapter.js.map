{"version":3,"file":"alpheios-tufts-adapter.js","sources":["../node_modules/alpheios-morph-client/src/base_adapter.js","../node_modules/alpheios-data-models/src/constants.js","../node_modules/alpheios-data-models/src/feature.js","../node_modules/alpheios-data-models/src/feature_type.js","../node_modules/alpheios-data-models/src/language_model.js","../node_modules/alpheios-data-models/src/latin_language_model.js","../node_modules/alpheios-data-models/src/greek_language_model.js","../node_modules/alpheios-data-models/src/arabic_language_model.js","../node_modules/alpheios-data-models/src/language_model_factory.js","../node_modules/alpheios-data-models/src/feature_list.js","../node_modules/alpheios-data-models/src/feature_importer.js","../node_modules/alpheios-data-models/src/lemma.js","../node_modules/alpheios-data-models/src/inflection.js","../node_modules/alpheios-data-models/src/lexeme.js","../node_modules/alpheios-data-models/src/homonym.js","../src/lib/lib.js","../src/lib/engine/whitakers.js","../src/lib/engine/morpheusgrc.js","../src/lib/engine/aramorph.js","../src/lib/engine/data/test-data.js","../src/adapter.js"],"sourcesContent":["/**\n * Base Adapter Class for a Morphology Service Client\n */\nclass BaseAdapter {\n  /**\n   * Method which is used to prepare a lookup request according\n   * to the adapter specific logic\n   * @param {string} lang - the language code\n   * @param {string} word - the word to lookup\n   * @returns {string} the url for the request\n   */\n  prepareRequestUrl (lang, word) {\n      /** must be overridden in the adapter implementation class **/\n    return null\n  }\n\n  /**\n   * Fetch response from a remote URL\n   * @param {string} lang - the language code\n   * @param {string} word - the word to lookup\n   * @returns {Promise} a promse which if successful resolves to json response object\n   *                    with the results of the analysis\n   */\n  fetch (lang, word) {\n    let url = this.prepareRequestUrl(lang, word)\n    return new Promise((resolve, reject) => {\n      window.fetch(url).then(\n          function (response) {\n            let json = response.json()\n            resolve(json)\n          }\n        ).catch((error) => {\n          reject(error)\n        }\n        )\n    })\n  }\n\n  /**\n   * Fetch test data to test the adapter\n   * @param {string} lang - the language code\n   * @param {string} word - the word to lookup\n   * @returns {Promise} a promse which if successful resolves to json response object\n   *                    with the test data\n   */\n  fetchTestData (lang, word) {\n    return new Promise((resolve, reject) => {\n      try {\n        let data = {}\n        resolve(data)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  /**\n   * A function that maps a morphological service's specific data types and values into an inflection library standard.\n   * @param {object} jsonObj - A JSON data from the fetch request\n   * @param {object} targetWord - the original target word of the analysis\n   * @returns {Homonym} A library standard Homonym object.\n   */\n  transform (jsonObj, targetWord) {\n    return {}\n  }\n}\n\nexport default BaseAdapter\n","/* eslint-disable no-unused-vars */\nexport const LANG_UNIT_WORD = Symbol('word')\nexport const LANG_UNIT_CHAR = Symbol('char')\nexport const LANG_DIR_LTR = Symbol('ltr')\nexport const LANG_DIR_RTL = Symbol('rtl')\nexport const LANG_LATIN = Symbol('latin')\nexport const LANG_GREEK = Symbol('greek')\nexport const LANG_ARABIC = Symbol('arabic')\nexport const LANG_PERSIAN = Symbol('persian')\nexport const STR_LANG_CODE_LAT = 'lat'\nexport const STR_LANG_CODE_LA = 'la'\nexport const STR_LANG_CODE_GRC = 'grc'\nexport const STR_LANG_CODE_ARA = 'ara'\nexport const STR_LANG_CODE_AR = 'ar'\nexport const STR_LANG_CODE_FAR = 'far'\nexport const STR_LANG_CODE_PER = 'per'\n// parts of speech\nexport const POFS_ADJECTIVE = 'adjective'\nexport const POFS_ADVERB = 'adverb'\nexport const POFS_ADVERBIAL = 'adverbial'\nexport const POFS_ARTICLE = 'article'\nexport const POFS_CONJUNCTION = 'conjunction'\nexport const POFS_EXCLAMATION = 'exclamation'\nexport const POFS_INTERJECTION = 'interjection'\nexport const POFS_NOUN = 'noun'\nexport const POFS_NUMERAL = 'numeral'\nexport const POFS_PARTICLE = 'particle'\nexport const POFS_PREFIX = 'prefix'\nexport const POFS_PREPOSITION = 'preposition'\nexport const POFS_PRONOUN = 'pronoun'\nexport const POFS_SUFFIX = 'suffix'\nexport const POFS_SUPINE = 'supine'\nexport const POFS_VERB = 'verb'\nexport const POFS_VERB_PARTICIPLE = 'verb participle'\n// gender\nexport const GEND_MASCULINE = 'masculine'\nexport const GEND_FEMININE = 'feminine'\nexport const GEND_NEUTER = 'neuter'\nexport const GEND_COMMON = 'common'\nexport const GEND_ANIMATE = 'animate'\nexport const GEND_INANIMATE = 'inanimate'\n// Polish gender types\nexport const GEND_PERSONAL_MASCULINE = 'personal masculine'\nexport const GEND_ANIMATE_MASCULINE = 'animate masculine'\nexport const GEND_INANIMATE_MASCULINE = 'inanimate masculine'\n// comparative\nexport const COMP_POSITIVE = 'positive'\nexport const COMP_COMPARITIVE = 'comparative'\nexport const COMP_SUPERLATIVE = 'superlative'\n// case\nexport const CASE_ABESSIVE = 'abessive'\nexport const CASE_ABLATIVE = 'ablative'\nexport const CASE_ABSOLUTIVE = 'absolutive'\nexport const CASE_ACCUSATIVE = 'accusative'\nexport const CASE_ADDIRECTIVE = 'addirective'\nexport const CASE_ADELATIVE = 'adelative'\nexport const CASE_ADESSIVE = 'adessive'\nexport const CASE_ADVERBIAL = 'adverbial'\nexport const CASE_ALLATIVE = 'allative'\nexport const CASE_ANTESSIVE = 'antessive'\nexport const CASE_APUDESSIVE = 'apudessive'\nexport const CASE_AVERSIVE = 'aversive'\nexport const CASE_BENEFACTIVE = 'benefactive'\nexport const CASE_CARITIVE = 'caritive'\nexport const CASE_CAUSAL = 'causal'\nexport const CASE_CAUSAL_FINAL = 'causal-final'\nexport const CASE_COMITATIVE = 'comitative'\nexport const CASE_DATIVE = 'dative'\nexport const CASE_DELATIVE = 'delative'\nexport const CASE_DIRECT = 'direct'\nexport const CASE_DISTRIBUTIVE = 'distributive'\nexport const CASE_DISTRIBUTIVE_TEMPORAL = 'distributive-temporal'\nexport const CASE_ELATIVE = 'elative'\nexport const CASE_ERGATIVE = 'ergative'\nexport const CASE_ESSIVE = 'essive'\nexport const CASE_ESSIVE_FORMAL = 'essive-formal'\nexport const CASE_ESSIVE_MODAL = 'essive-modal'\nexport const CASE_EQUATIVE = 'equative'\nexport const CASE_EVITATIVE = 'evitative'\nexport const CASE_EXESSIVE = 'exessive'\nexport const CASE_FINAL = 'final'\nexport const CASE_FORMAL = 'formal'\nexport const CASE_GENITIVE = 'genitive'\nexport const CASE_ILLATIVE = 'illative'\nexport const CASE_INELATIVE = 'inelative'\nexport const CASE_INESSIVE = 'inessive'\nexport const CASE_INSTRUCTIVE = 'instructive'\nexport const CASE_INSTRUMENTAL = 'instrumental'\nexport const CASE_INSTRUMENTAL_COMITATIVE = 'instrumental-comitative'\nexport const CASE_INTRANSITIVE = 'intransitive'\nexport const CASE_LATIVE = 'lative'\nexport const CASE_LOCATIVE = 'locative'\nexport const CASE_MODAL = 'modal'\nexport const CASE_MULTIPLICATIVE = 'multiplicative'\nexport const CASE_NOMINATIVE = 'nominative'\nexport const CASE_PARTITIVE = 'partitive'\nexport const CASE_PEGATIVE = 'pegative'\nexport const CASE_PERLATIVE = 'perlative'\nexport const CASE_POSSESSIVE = 'possessive'\nexport const CASE_POSTELATIVE = 'postelative'\nexport const CASE_POSTDIRECTIVE = 'postdirective'\nexport const CASE_POSTESSIVE = 'postessive'\nexport const CASE_POSTPOSITIONAL = 'postpositional'\nexport const CASE_PREPOSITIONAL = 'prepositional'\nexport const CASE_PRIVATIVE = 'privative'\nexport const CASE_PROLATIVE = 'prolative'\nexport const CASE_PROSECUTIVE = 'prosecutive'\nexport const CASE_PROXIMATIVE = 'proximative'\nexport const CASE_SEPARATIVE = 'separative'\nexport const CASE_SOCIATIVE = 'sociative'\nexport const CASE_SUBDIRECTIVE = 'subdirective'\nexport const CASE_SUBESSIVE = 'subessive'\nexport const CASE_SUBELATIVE = 'subelative'\nexport const CASE_SUBLATIVE = 'sublative'\nexport const CASE_SUPERDIRECTIVE = 'superdirective'\nexport const CASE_SUPERESSIVE = 'superessive'\nexport const CASE_SUPERLATIVE = 'superlative'\nexport const CASE_SUPPRESSIVE = 'suppressive'\nexport const CASE_TEMPORAL = 'temporal'\nexport const CASE_TERMINATIVE = 'terminative'\nexport const CASE_TRANSLATIVE = 'translative'\nexport const CASE_VIALIS = 'vialis'\nexport const CASE_VOCATIVE = 'vocative'\nexport const MOOD_ADMIRATIVE = 'admirative'\nexport const MOOD_COHORTATIVE = 'cohortative'\nexport const MOOD_CONDITIONAL = 'conditional'\nexport const MOOD_DECLARATIVE = 'declarative'\nexport const MOOD_DUBITATIVE = 'dubitative'\nexport const MOOD_ENERGETIC = 'energetic'\nexport const MOOD_EVENTIVE = 'eventive'\nexport const MOOD_GENERIC = 'generic'\nexport const MOOD_GERUNDIVE = 'gerundive'\nexport const MOOD_HYPOTHETICAL = 'hypothetical'\nexport const MOOD_IMPERATIVE = 'imperative'\nexport const MOOD_INDICATIVE = 'indicative'\nexport const MOOD_INFERENTIAL = 'inferential'\nexport const MOOD_INFINITIVE = 'infinitive'\nexport const MOOD_INTERROGATIVE = 'interrogative'\nexport const MOOD_JUSSIVE = 'jussive'\nexport const MOOD_NEGATIVE = 'negative'\nexport const MOOD_OPTATIVE = 'optative'\nexport const MOOD_PARTICIPLE = 'participle'\nexport const MOOD_PRESUMPTIVE = 'presumptive'\nexport const MOOD_RENARRATIVE = 'renarrative'\nexport const MOOD_SUBJUNCTIVE = 'subjunctive'\nexport const MOOD_SUPINE = 'supine'\nexport const NUM_SINGULAR = 'singular'\nexport const NUM_PLURAL = 'plural'\nexport const NUM_DUAL = 'dual'\nexport const NUM_TRIAL = 'trial'\nexport const NUM_PAUCAL = 'paucal'\nexport const NUM_SINGULATIVE = 'singulative'\nexport const NUM_COLLECTIVE = 'collective'\nexport const NUM_DISTRIBUTIVE_PLURAL = 'distributive plural'\nexport const NRL_CARDINAL = 'cardinal'\nexport const NRL_ORDINAL = 'ordinal'\nexport const NRL_DISTRIBUTIVE = 'distributive'\nexport const NURL_NUMERAL_ADVERB = 'numeral adverb'\nexport const ORD_1ST = '1st'\nexport const ORD_2ND = '2nd'\nexport const ORD_3RD = '3rd'\nexport const ORD_4TH = '4th'\nexport const ORD_5TH = '5th'\nexport const ORD_6TH = '6th'\nexport const ORD_7TH = '7th'\nexport const ORD_8TH = '8th'\nexport const ORD_9TH = '9th'\nexport const TENSE_AORIST = 'aorist'\nexport const TENSE_FUTURE = 'future'\nexport const TENSE_FUTURE_PERFECT = 'future perfect'\nexport const TENSE_IMPERFECT = 'imperfect'\nexport const TENSE_PAST_ABSOLUTE = 'past absolute'\nexport const TENSE_PERFECT = 'perfect'\nexport const TENSE_PLUPERFECT = 'pluperfect'\nexport const TENSE_PRESENT = 'present'\nexport const VKIND_TO_BE = 'to be'\nexport const VKIND_COMPOUNDS_OF_TO_BE = 'compounds of to be'\nexport const VKIND_TAKING_ABLATIVE = 'taking ablative'\nexport const VKIND_TAKING_DATIVE = 'taking dative'\nexport const VKIND_TAKING_GENITIVE = 'taking genitive'\nexport const VKIND_TRANSITIVE = 'transitive'\nexport const VKIND_INTRANSITIVE = 'intransitive'\nexport const VKIND_IMPERSONAL = 'impersonal'\nexport const VKIND_DEPONENT = 'deponent'\nexport const VKIND_SEMIDEPONENT = 'semideponent'\nexport const VKIND_PERFECT_DEFINITE = 'perfect definite'\nexport const VOICE_ACTIVE = 'active'\nexport const VOICE_PASSIVE = 'passive'\nexport const VOICE_MEDIOPASSIVE = 'mediopassive'\nexport const VOICE_IMPERSONAL_PASSIVE = 'impersonal passive'\nexport const VOICE_MIDDLE = 'middle'\nexport const VOICE_ANTIPASSIVE = 'antipassive'\nexport const VOICE_REFLEXIVE = 'reflexive'\nexport const VOICE_RECIPROCAL = 'reciprocal'\nexport const VOICE_CAUSATIVE = 'causative'\nexport const VOICE_ADJUTATIVE = 'adjutative'\nexport const VOICE_APPLICATIVE = 'applicative'\nexport const VOICE_CIRCUMSTANTIAL = 'circumstantial'\nexport const VOICE_DEPONENT = 'deponent'\nexport const TYPE_IRREGULAR = 'irregular'\nexport const TYPE_REGULAR = 'regular'\n/* eslit-enable no-unused-vars */\n","\n/**\n * Wrapper class for a (grammatical, usually) feature, such as part of speech or declension. Keeps both value and type information.\n */\nclass Feature {\n    /**\n     * Initializes a Feature object\n     * @param {string | string[]} value - A single feature value or, if this feature could have multiple\n     * values, an array of values.\n     * @param {string} type - A type of the feature, allowed values are specified in 'types' object.\n     * @param {string} language - A language of a feature, allowed values are specified in 'languages' object.\n     */\n  constructor (value, type, language) {\n    if (!Feature.types.isAllowed(type)) {\n      throw new Error('Features of \"' + type + '\" type are not supported.')\n    }\n    if (!value) {\n      throw new Error('Feature should have a non-empty value.')\n    }\n    if (!type) {\n      throw new Error('Feature should have a non-empty type.')\n    }\n    if (!language) {\n      throw new Error('Feature constructor requires a language')\n    }\n    this.value = value\n    this.type = type\n    this.language = language\n  };\n\n  isEqual (feature) {\n    if (Array.isArray(feature.value)) {\n      if (!Array.isArray(this.value) || this.value.length !== feature.value.length) {\n        return false\n      }\n      let equal = this.type === feature.type && this.language === feature.language\n      equal = equal && this.value.every(function (element, index) {\n        return element === feature.value[index]\n      })\n      return equal\n    } else {\n      return this.value === feature.value && this.type === feature.type && this.language === feature.language\n    }\n  }\n}\n// Should have no spaces in values in order to be used in HTML templates\nFeature.types = {\n  word: 'word',\n  part: 'part of speech', // Part of speech\n  number: 'number',\n  grmCase: 'case',\n  declension: 'declension',\n  gender: 'gender',\n  type: 'type',\n  conjugation: 'conjugation',\n  comparison: 'comparison',\n  tense: 'tense',\n  voice: 'voice',\n  mood: 'mood',\n  person: 'person',\n  frequency: 'frequency', // How frequent this word is\n  meaning: 'meaning', // Meaning of a word\n  source: 'source', // Source of word definition\n  footnote: 'footnote', // A footnote for a word's ending\n  dialect: 'dialect', // a dialect iderntifier\n  note: 'note', // a general note\n  pronunciation: 'pronunciation',\n  area: 'area',\n  geo: 'geo', // geographical data\n  kind: 'kind', // verb kind informatin\n  derivtype: 'derivtype',\n  stemtype: 'stemtype',\n  morph: 'morph', // general morphological information\n  var: 'var', // variance?\n  isAllowed (value) {\n    let v = `${value}`\n    return Object.values(this).includes(v)\n  }\n}\nexport default Feature\n","import Feature from './feature.js'\n\n/**\n * Definition class for a (grammatical) feature. Stores type information and (optionally) all possible values of the feature.\n * It serves as a feature generator. If list of possible values is provided, it can generate a Feature object\n * each time a property that corresponds to a feature value is accessed. If no list of possible values provided,\n * a Feature object can be generated with get(value) method.\n *\n * An order of values determines a default sort and grouping order. If two values should have the same order,\n * they should be grouped within an array: value1, [value2, value3], value4. Here 'value2' and 'value3' have\n * the same priority for sorting and grouping.\n */\nclass FeatureType {\n    // TODO: value checking\n    /**\n     * Creates and initializes a Feature Type object.\n     * @param {string} type - A type of the feature, allowed values are specified in 'types' object.\n     * @param {string[] | string[][]} values - A list of allowed values for this feature type.\n     * If an empty array is provided, there will be no\n     * allowed values as well as no ordering (can be used for items that do not need or have a simple order,\n     * such as footnotes).\n     * @param {string} language - A language of a feature, allowed values are specified in 'languages' object.\n     */\n  constructor (type, values, language) {\n    if (!Feature.types.isAllowed(type)) {\n      throw new Error('Features of \"' + type + '\" type are not supported.')\n    }\n    if (!values || !Array.isArray(values)) {\n      throw new Error('Values should be an array (or an empty array) of values.')\n    }\n    if (!language) {\n      throw new Error('FeatureType constructor requires a language')\n    }\n\n    this.type = type\n    this.language = language\n\n        /*\n         This is a sort order index for a grammatical feature values. It is determined by the order of values in\n         a 'values' array.\n         */\n    this._orderIndex = []\n    this._orderLookup = {}\n\n    for (const [index, value] of values.entries()) {\n      this._orderIndex.push(value)\n      if (Array.isArray(value)) {\n        for (let element of value) {\n          this[element] = new Feature(element, this.type, this.language)\n          this._orderLookup[element] = index\n        }\n      } else {\n        this[value] = new Feature(value, this.type, this.language)\n        this._orderLookup[value] = index\n      }\n    }\n  };\n\n    /**\n     * Return a Feature with an arbitrary value. This value would not be necessarily present among FeatureType values.\n     * This can be especially useful for features that do not set: a list of predefined values, such as footnotes.\n     * @param value\n     * @returns {Feature}\n     */\n  get (value) {\n    if (value) {\n      return new Feature(value, this.type, this.language)\n    } else {\n      throw new Error('A non-empty value should be provided.')\n    }\n  }\n\n    /**\n     * Creates and returns a new importer with a specific name. If an importer with this name already exists,\n     * an existing Importer object will be returned.\n     * @param {string} name - A name of an importer object\n     * @returns {Importer} A new or existing Importer object that matches a name provided\n     */\n  addImporter (name) {\n    if (!name) {\n      throw new Error('Importer should have a non-empty name.')\n    }\n    this.importer = this.importer || {}\n    this.importer[name] = this.importer[name] || new Importer()\n    return this.importer[name]\n  }\n\n    /**\n     * Return copies of all feature values as Feature objects in a sorted array, according to feature type's sort order.\n     * For a similar function that returns strings instead of Feature objects see orderedValues().\n     * @returns {Feature[] | Feature[][]} Array of feature values sorted according to orderIndex.\n     * If particular feature contains multiple feature values (i.e. `masculine` and `feminine` values combined),\n     * an array of Feature objects will be returned instead of a single Feature object, as for single feature values.\n     */\n  get orderedFeatures () {\n    return this.orderedValues.map((value) => new Feature(value, this.type, this.language))\n  }\n\n    /**\n     * Return all feature values as strings in a sorted array, according to feature type's sort order.\n     * This is a main method that specifies a sort order of the feature type. orderedFeatures() relies\n     * on this method in providing a sorted array of feature values. If you want to create\n     * a custom sort order for a particular feature type that will depend on some options that are not type-related,\n     * create a wrapper around this function providing it with options arguments so it will be able to decide\n     * in what order those features will be based on those arguments.\n     * For a similar function that returns Feature objects instead of strings see orderedValues().\n     * @returns {string[]} Array of feature values sorted according to orderIndex.\n     * If particular feature contains multiple feature values (i.e. `masculine` and `feminine` values combined),\n     * an array of strings will be returned instead of a single strings, as for single feature values.\n     */\n  get orderedValues () {\n    return this._orderIndex\n  }\n\n    /**\n     * Returns a lookup table for type values as:\n     *  {value1: order1, value2: order2}, where order is a sort order of an item. If two items have the same sort order,\n     *  their order value will be the same.\n     * @returns {object}\n     */\n  get orderLookup () {\n    return this._orderLookup\n  }\n\n    /**\n     * Sets an order of grammatical feature values for a grammatical feature. Used mostly for sorting, filtering,\n     * and displaying.\n     *\n     * @param {Feature[] | Feature[][]} values - a list of grammatical features that specify their order for\n     * sorting and filtering. Some features can be grouped as [[genders.masculine, genders.feminine], LibLatin.genders.neuter].\n     * It means that genders.masculine and genders.feminine belong to the same group. They will have the same index\n     * and will be stored inside an _orderIndex as an array. genders.masculine and genders.feminine will be grouped together\n     * during filtering and will be in the same bin during sorting.\n     *\n     */\n  set order (values) {\n    if (!values || (Array.isArray(values) && values.length === 0)) {\n      throw new Error('A non-empty list of values should be provided.')\n    }\n\n        // If a single value is provided, convert it into an array\n    if (!Array.isArray(values)) {\n      values = [values]\n    }\n\n    for (let value of values) {\n      if (Array.isArray(value)) {\n        for (let element of value) {\n          if (!this.hasOwnProperty(element.value)) {\n            throw new Error('Trying to order an element with \"' + element.value + '\" value that is not stored in a \"' + this.type + '\" type.')\n          }\n\n          if (element.type !== this.type) {\n            throw new Error('Trying to order an element with type \"' + element.type + '\" that is different from \"' + this.type + '\".')\n          }\n\n          if (element.language !== this.language) {\n            throw new Error('Trying to order an element with language \"' + element.language + '\" that is different from \"' + this.language + '\".')\n          }\n        }\n      } else {\n        if (!this.hasOwnProperty(value.value)) {\n          throw new Error('Trying to order an element with \"' + value.value + '\" value that is not stored in a \"' + this.type + '\" type.')\n        }\n\n        if (value.type !== this.type) {\n          throw new Error('Trying to order an element with type \"' + value.type + '\" that is different from \"' + this.type + '\".')\n        }\n\n        if (value.language !== this.language) {\n          throw new Error('Trying to order an element with language \"' + value.language + '\" that is different from \"' + this.language + '\".')\n        }\n      }\n    }\n\n        // Erase whatever sort order was set previously\n    this._orderLookup = {}\n    this._orderIndex = []\n\n        // Define a new sort order\n    for (const [index, element] of values.entries()) {\n      if (Array.isArray(element)) {\n                // If it is an array, all values should have the same order\n        let elements = []\n        for (const subElement of element) {\n          this._orderLookup[subElement.value] = index\n          elements.push(subElement.value)\n        }\n        this._orderIndex[index] = elements\n      } else {\n                // If is a single value\n        this._orderLookup[element.value] = index\n        this._orderIndex[index] = element.value\n      }\n    }\n  }\n}\n\n/**\n * This is a hash table that maps values to be imported from an external file or service to library standard values.\n */\nclass Importer {\n  constructor () {\n    this.hash = {}\n    return this\n  }\n\n    /**\n     * Sets mapping between external imported value and one or more library standard values. If an importedValue\n     * is already in a hash table, old libraryValue will be overwritten with the new one.\n     * @param {string} importedValue - External value\n     * @param {Object | Object[] | string | string[]} libraryValue - Library standard value\n     */\n  map (importedValue, libraryValue) {\n    if (!importedValue) {\n      throw new Error('Imported value should not be empty.')\n    }\n\n    if (!libraryValue) {\n      throw new Error('Library value should not be empty.')\n    }\n\n    this.hash[importedValue] = libraryValue\n    return this\n  }\n\n    /**\n     * Checks if value is in a map.\n     * @param {string} importedValue - A value to test.\n     * @returns {boolean} - Tru if value is in a map, false otherwise.\n     */\n  has (importedValue) {\n    return this.hash.hasOwnProperty(importedValue)\n  }\n\n    /**\n     * Returns one or more library standard values that match an external value\n     * @param {string} importedValue - External value\n     * @returns {Object | string} One or more of library standard values\n     */\n  get (importedValue) {\n    if (this.has(importedValue)) {\n      return this.hash[importedValue]\n    } else {\n      throw new Error('A value \"' + importedValue + '\" is not found in the importer.')\n    }\n  }\n}\nexport default FeatureType\n","import * as Constants from './constants.js'\nimport Feature from './feature.js'\nimport FeatureType from './feature_type.js'\n\n/**\n * @class  LanguageModel is the base class for language-specific behavior\n */\nclass LanguageModel {\n   /**\n   */\n  constructor () {\n    this.sourceLanguage = null\n    this.contextForward = 0\n    this.context_backward = 0\n    this.direction = Constants.LANG_DIR_LTR\n    this.baseUnit = Constants.LANG_UNIT_WORD\n    this.codes = []\n  }\n\n  _initializeFeatures () {\n    let features = {}\n    let code = this.toCode()\n    features[Feature.types.part] = new FeatureType(Feature.types.part,\n      [ Constants.POFS_ADVERB,\n        Constants.POFS_ADVERBIAL,\n        Constants.POFS_ADJECTIVE,\n        Constants.POFS_ARTICLE,\n        Constants.POFS_CONJUNCTION,\n        Constants.POFS_EXCLAMATION,\n        Constants.POFS_INTERJECTION,\n        Constants.POFS_NOUN,\n        Constants.POFS_NUMERAL,\n        Constants.POFS_PARTICLE,\n        Constants.POFS_PREFIX,\n        Constants.POFS_PREPOSITION,\n        Constants.POFS_PRONOUN,\n        Constants.POFS_SUFFIX,\n        Constants.POFS_SUPINE,\n        Constants.POFS_VERB,\n        Constants.POFS_VERB_PARTICIPLE ], code)\n    features[Feature.types.gender] = new FeatureType(Feature.types.gender,\n      [ Constants.GEND_MASCULINE, Constants.GEND_FEMININE, Constants.GEND_NEUTER ], code)\n    features[Feature.types.type] = new FeatureType(Feature.types.type,\n      [Constants.TYPE_REGULAR, Constants.TYPE_IRREGULAR], code)\n    features[Feature.types.person] = new FeatureType(Feature.types.person,\n      [Constants.ORD_1ST, Constants.ORD_2ND, Constants.ORD_3RD], code)\n    return features\n  }\n\n  /**\n   * Handler which can be used as the contextHander.\n   * It uses language-specific configuration to identify\n   * the elements from the alph-text popup which should produce links\n   * to the language-specific grammar.\n   * @see #contextHandler\n   */\n  grammarContext (doc) {\n      // used to bind a click handler on the .alph-entry items in the\n      // popup which retrieved the context attribute from the clicked\n      // term and used that to construct a link and open the grammar\n      // at the apporopriate place.\n      // var links = this.getGrammarLinks();\n\n      // for (var link_name in links)\n      // {\n      //   if (links.hasOwnProperty(link_name))\n      //    {\n              // Alph.$(\".alph-entry .\" + link_name,a_doc).bind('click',link_name,\n              //   function(a_e)\n              //    {\n                        // build target inside grammar\n                        // var target = a_e.data;\n                        // var rngContext = Alph.$(this).attr(\"context\");\n                        // if (rngContext != null)\n                        // {\n                        //  target += \"-\" + rngContext.split(/-/)[0];\n                        // }\n                        // myobj.openGrammar(a_e.originaEvent,this,target);\n               //   }\n              // );\n       //   }\n      // }\n  }\n\n  /**\n   * Check to see if this language tool can produce an inflection table display\n   * for the current node\n   */\n  canInflect (node) {\n    return false\n  }\n\n  /**\n   * Check to see if the supplied language code is supported by this tool\n   * @param {string} code the language code\n   * @returns true if supported false if not\n   * @type Boolean\n   */\n  static supportsLanguage (code) {\n    return this.codes.includes[code]\n  }\n\n  /**\n   * Return a normalized version of a word which can be used to compare the word for equality\n   * @param {string} word the source word\n   * @returns the normalized form of the word (default version just returns the same word,\n   *          override in language-specific subclass)\n   * @type String\n   */\n  normalizeWord (word) {\n    return word\n  }\n\n  /**\n   * Get a list of valid puncutation for this language\n   * @returns {String} a string containing valid puncutation symbols\n   */\n  getPunctuation () {\n    return \".,;:!?'\\\"(){}\\\\[\\\\]<>/\\\\\\u00A0\\u2010\\u2011\\u2012\\u2013\\u2014\\u2015\\u2018\\u2019\\u201C\\u201D\\u0387\\u00B7\\n\\r\"\n  }\n\n  toString () {\n    return String(this.sourceLanguage)\n  }\n\n  isEqual (model) {\n    return this.sourceLanguage === model.sourceLanguage\n  }\n\n  toCode () {\n    return null\n  }\n}\n\nexport default LanguageModel\n","import LanguageModel from './language_model.js'\nimport Feature from './feature.js'\nimport FeatureType from './feature_type.js'\nimport * as Constants from './constants.js'\n/**\n * @class  LatinLanguageModel is the lass for Latin specific behavior\n */\nclass LatinLanguageModel extends LanguageModel {\n   /**\n   */\n  constructor () {\n    super()\n    this.sourceLanguage = Constants.LANG_LATIN\n    this.contextForward = 0\n    this.contextBackward = 0\n    this.direction = Constants.LANG_DIR_LTR\n    this.baseUnit = Constants.LANG_UNIT_WORD\n    this.codes = [Constants.STR_LANG_CODE_LA, Constants.STR_LANG_CODE_LAT]\n    this.features = this._initializeFeatures()\n  }\n\n  _initializeFeatures () {\n    let features = super._initializeFeatures()\n    let code = this.toCode()\n    features[Feature.types.number] = new FeatureType(Feature.types.number, [Constants.NUM_SINGULAR, Constants.NUM_PLURAL], code)\n    features[Feature.types.grmCase] = new FeatureType(Feature.types.grmCase,\n      [ Constants.CASE_NOMINATIVE,\n        Constants.CASE_GENITIVE,\n        Constants.CASE_DATIVE,\n        Constants.CASE_ACCUSATIVE,\n        Constants.CASE_ABLATIVE,\n        Constants.CASE_LOCATIVE,\n        Constants.CASE_VOCATIVE\n      ], code)\n    features[Feature.types.declension] = new FeatureType(Feature.types.declension,\n      [ Constants.ORD_1ST, Constants.ORD_2ND, Constants.ORD_3RD, Constants.ORD_4TH, Constants.ORD_5TH ], code)\n    features[Feature.types.tense] = new FeatureType(Feature.types.tense,\n      [ Constants.TENSE_PRESENT,\n        Constants.TENSE_IMPERFECT,\n        Constants.TENSE_FUTURE,\n        Constants.TENSE_PERFECT,\n        Constants.TENSE_PLUPERFECT,\n        Constants.TENSE_FUTURE_PERFECT\n      ], code)\n    features[Feature.types.voice] = new FeatureType(Feature.types.voice, [Constants.VOICE_PASSIVE, Constants.VOICE_ACTIVE], code)\n    features[Feature.types.mood] = new FeatureType(Feature.types.mood, [Constants.MOOD_INDICATIVE, Constants.MOOD_SUBJUNCTIVE], code)\n    features[Feature.types.conjugation] = new FeatureType(Feature.types.conjugation,\n      [ Constants.ORD_1ST,\n        Constants.ORD_2ND,\n        Constants.ORD_3RD,\n        Constants.ORD_4TH\n      ], code)\n    return features\n  }\n\n  /**\n   * Check to see if this language tool can produce an inflection table display\n   * for the current node\n   */\n  canInflect (node) {\n    return true\n  }\n\n  /**\n   * Return a normalized version of a word which can be used to compare the word for equality\n   * @param {String} word the source word\n   * @returns the normalized form of the word (default version just returns the same word,\n   *          override in language-specific subclass)\n   * @type String\n   */\n  normalizeWord (word) {\n    return word\n  }\n\n  /**\n   * Get a list of valid puncutation for this language\n   * @returns {String} a string containing valid puncutation symbols\n   */\n  getPunctuation () {\n    return \".,;:!?'\\\"(){}\\\\[\\\\]<>/\\\\\\u00A0\\u2010\\u2011\\u2012\\u2013\\u2014\\u2015\\u2018\\u2019\\u201C\\u201D\\u0387\\u00B7\\n\\r\"\n  }\n\n  toCode () {\n    return Constants.STR_LANG_CODE_LAT\n  }\n}\nexport default LatinLanguageModel\n","import LanguageModel from './language_model.js'\nimport * as Constants from './constants.js'\nimport Feature from './feature.js'\nimport FeatureType from './feature_type.js'\n\n/**\n * @class  LatinLanguageModel is the lass for Latin specific behavior\n */\nclass GreekLanguageModel extends LanguageModel {\n   /**\n   * @constructor\n   */\n  constructor () {\n    super()\n    this.sourceLanguage = Constants.LANG_GREEK\n    this.contextForward = 0\n    this.contextBackward = 0\n    this.direction = Constants.LANG_DIR_LTR\n    this.baseUnit = Constants.LANG_UNIT_WORD\n    this.languageCodes = [Constants.STR_LANG_CODE_GRC]\n    this.features = this._initializeFeatures()\n  }\n\n  _initializeFeatures () {\n    let features = super._initializeFeatures()\n    let code = this.toCode()\n    features[Feature.types.number] = new FeatureType(Feature.types.number, [Constants.NUM_SINGULAR, Constants.NUM_PLURAL, Constants.NUM_DUAL], code)\n    features[Feature.types.grmCase] = new FeatureType(Feature.types.grmCase,\n      [ Constants.CASE_NOMINATIVE,\n        Constants.CASE_GENITIVE,\n        Constants.CASE_DATIVE,\n        Constants.CASE_ACCUSATIVE,\n        Constants.CASE_VOCATIVE\n      ], code)\n    features[Feature.types.declension] = new FeatureType(Feature.types.declension,\n      [ Constants.ORD_1ST, Constants.ORD_2ND, Constants.ORD_3RD ], code)\n    features[Feature.types.tense] = new FeatureType(Feature.types.tense,\n      [ Constants.TENSE_PRESENT,\n        Constants.TENSE_IMPERFECT,\n        Constants.TENSE_FUTURE,\n        Constants.TENSE_PERFECT,\n        Constants.TENSE_PLUPERFECT,\n        Constants.TENSE_FUTURE_PERFECT,\n        Constants.TENSE_AORIST\n      ], code)\n    features[Feature.types.voice] = new FeatureType(Feature.types.voice,\n      [ Constants.VOICE_PASSIVE,\n        Constants.VOICE_ACTIVE,\n        Constants.VOICE_MEDIOPASSIVE,\n        Constants.VOICE_MIDDLE\n      ], code)\n    features[Feature.types.mood] = new FeatureType(Feature.types.mood,\n      [ Constants.MOOD_INDICATIVE,\n        Constants.MOOD_SUBJUNCTIVE,\n        Constants.MOOD_OPTATIVE,\n        Constants.MOOD_IMPERATIVE\n      ], code)\n    // TODO full list of greek dialects\n    features[Feature.types.dialect] = new FeatureType(Feature.types.dialect, ['attic', 'epic', 'doric'], code)\n    return features\n  }\n\n  toCode () {\n    return Constants.STR_LANG_CODE_GRC\n  }\n\n  /**\n   * Check to see if this language tool can produce an inflection table display\n   * for the current node\n   */\n  canInflect (node) {\n    return true\n  }\n\n  /**\n   * Return a normalized version of a word which can be used to compare the word for equality\n   * @param {String} word the source word\n   * @returns the normalized form of the word (default version just returns the same word,\n   *          override in language-specific subclass)\n   * @type String\n   */\n  normalizeWord (word) {\n    return word\n  }\n\n  /**\n   * Get a list of valid puncutation for this language\n   * @returns {String} a string containing valid puncutation symbols\n   */\n  getPunctuation () {\n    return \".,;:!?'\\\"(){}\\\\[\\\\]<>/\\\\\\u00A0\\u2010\\u2011\\u2012\\u2013\\u2014\\u2015\\u2018\\u2019\\u201C\\u201D\\u0387\\u00B7\\n\\r\"\n  }\n}\nexport default GreekLanguageModel\n","import LanguageModel from './language_model.js'\nimport * as Constants from './constants.js'\n\n/**\n * @class  LatinLanguageModel is the lass for Latin specific behavior\n */\nclass ArabicLanguageModel extends LanguageModel {\n   /**\n   * @constructor\n   */\n  constructor () {\n    super()\n    this.sourceLanguage = Constants.LANG_ARABIC\n    this.contextForward = 0\n    this.contextBackward = 0\n    this.direction = Constants.LANG_DIR_RTL\n    this.baseUnit = Constants.LANG_UNIT_WORD\n    this.languageCodes = [Constants.STR_LANG_CODE_ARA, Constants.STR_LANG_CODE_AR]\n    this._initializeFeatures()\n  }\n\n  _initializeFeatures () {\n    this.features = super._initializeFeatures()\n  }\n\n  toCode () {\n    return Constants.STR_LANG_CODE_ARA\n  }\n\n  /**\n   * Check to see if this language tool can produce an inflection table display\n   * for the current node\n   */\n  canInflect (node) {\n    return false\n  }\n\n  /**\n   * Return a normalized version of a word which can be used to compare the word for equality\n   * @param {String} word the source word\n   * @returns the normalized form of the word (default version just returns the same word,\n   *          override in language-specific subclass)\n   * @type String\n   */\n  normalizeWord (word) {\n    // TODO\n    return word\n  }\n\n  /**\n   * Get a list of valid puncutation for this language\n   * @returns {String} a string containing valid puncutation symbols\n   */\n  getPunctuation () {\n    return \".,;:!?'\\\"(){}\\\\[\\\\]<>/\\\\\\u00A0\\u2010\\u2011\\u2012\\u2013\\u2014\\u2015\\u2018\\u2019\\u201C\\u201D\\u0387\\u00B7\\n\\r\"\n  }\n}\nexport default ArabicLanguageModel\n","import LanguageModel from './language_model.js'\nimport LatinLanguageModel from './latin_language_model.js'\nimport GreekLanguageModel from './greek_language_model.js'\nimport ArabicLanguageModel from './arabic_language_model.js'\nimport * as Constants from './constants.js'\n\nconst MODELS = new Map([\n  [ Constants.STR_LANG_CODE_LA, LatinLanguageModel ],\n  [ Constants.STR_LANG_CODE_LAT, LatinLanguageModel ],\n  [ Constants.STR_LANG_CODE_GRC, GreekLanguageModel ],\n  [ Constants.STR_LANG_CODE_ARA, ArabicLanguageModel ],\n  [ Constants.STR_LANG_CODE_AR, ArabicLanguageModel ]\n])\n\nclass LanguageModelFactory {\n  static supportsLanguage (code) {\n    return MODELS.has(code)\n  }\n\n  static getLanguageForCode (code = null) {\n    let Model = MODELS.get(code)\n    if (Model) {\n      return new Model()\n    }\n    // for now return a default Model\n    // TODO may want to throw an error\n    return new LanguageModel()\n  }\n}\nexport default LanguageModelFactory\n","/**\n * A list of grammatical features that characterizes a language unit. Has some additional service methods,\n * compared with standard storage objects.\n */\nclass FeatureList {\n    /**\n     * Initializes a feature list.\n     * @param {FeatureType[]} features - Features that build the list (optional, can be set later).\n     */\n  constructor (features = []) {\n    this._features = []\n    this._types = {}\n    this.add(features)\n  }\n\n  add (features) {\n    if (!features || !Array.isArray(features)) {\n      throw new Error('Features must be defined and must come in an array.')\n    }\n\n    for (let feature of features) {\n      this._features.push(feature)\n      this._types[feature.type] = feature\n    }\n  }\n\n    /**\n     * Returns an array of grouping features.\n     * @returns {FeatureType[]} - An array of grouping features.\n     */\n  get items () {\n    return this._features\n  }\n\n  forEach (callback) {\n    this._features.forEach(callback)\n  }\n\n    /**\n     * Returns a feature of a particular type. If such feature does not exist in a list, returns undefined.\n     * @param {string} type - Feature type as defined in `types` object.\n     * @return {FeatureType | undefined} A feature if a particular type if contains it. Undefined otherwise.\n     */\n  ofType (type) {\n    if (this.hasType(type)) {\n      return this._types[type]\n    }\n  }\n\n    /**\n     * Checks whether a feature list has a feature of a specific type.\n     * @param {string} type - Feature type as defined in `types` object.\n     * @return {boolean} Whether a feature list has a feature of a particular type.\n     */\n  hasType (type) {\n    return this._types.hasOwnProperty(type)\n  }\n}\nexport default FeatureList\n","class FeatureImporter {\n  constructor () {\n    this.hash = {}\n    return this\n  }\n\n    /**\n     * Sets mapping between external imported value and one or more library standard values. If an importedValue\n     * is already in a hash table, old libraryValue will be overwritten with the new one.\n     * @param {string} importedValue - External value\n     * @param {Object | Object[] | string | string[]} libraryValue - Library standard value\n     */\n  map (importedValue, libraryValue) {\n    if (!importedValue) {\n      throw new Error('Imported value should not be empty.')\n    }\n\n    if (!libraryValue) {\n      throw new Error('Library value should not be empty.')\n    }\n\n    this.hash[importedValue] = libraryValue\n    return this\n  }\n\n    /**\n     * Checks if value is in a map.\n     * @param {string} importedValue - A value to test.\n     * @returns {boolean} - Tru if value is in a map, false otherwise.\n     */\n  has (importedValue) {\n    return this.hash.hasOwnProperty(importedValue)\n  }\n\n    /**\n     * Returns one or more library standard values that match an external value\n     * @param {string} importedValue - External value\n     * @returns {Object | string} One or more of library standard values\n     */\n  get (importedValue) {\n    if (this.has(importedValue)) {\n      return this.hash[importedValue]\n    } else {\n      throw new Error('A value \"' + importedValue + '\" is not found in the importer.')\n    }\n  }\n}\nexport default FeatureImporter\n","/**\n * Lemma, a canonical form of a word.\n */\nclass Lemma {\n    /**\n     * Initializes a Lemma object.\n     * @param {string} word - A word.\n     * @param {string} language - A language of a word.\n     */\n  constructor (word, language) {\n    if (!word) {\n      throw new Error('Word should not be empty.')\n    }\n\n    if (!language) {\n      throw new Error('Langauge should not be empty.')\n    }\n\n        // if (!languages.isAllowed(language)) {\n        //    throw new Error('Language \"' + language + '\" is not supported.');\n        // }\n\n    this.word = word\n    this.language = language\n  }\n\n  static readObject (jsonObject) {\n    return new Lemma(jsonObject.word, jsonObject.language)\n  }\n}\nexport default Lemma\n","import Feature from './feature.js'\nimport LanguageModelFactory from './language_model_factory.js'\n/*\n Hierarchical structure of return value of a morphological analyzer:\n\n Homonym (a group of words that are written the same way, https://en.wikipedia.org/wiki/Homonym)\n    Lexeme 1 (a unit of lexical meaning, https://en.wikipedia.org/wiki/Lexeme)\n        Have a lemma and one or more inflections\n        Lemma (also called a headword, a canonical form of a group of words https://en.wikipedia.org/wiki/Lemma_(morphology) )\n        Inflection 1\n            Stem\n            Suffix (also called ending)\n        Inflection 2\n            Stem\n            Suffix\n    Lexeme 2\n        Lemma\n        Inflection 1\n            Stem\n            Suffix\n */\n\n/**\n * Represents an inflection of a word\n */\nclass Inflection {\n    /**\n     * Initializes an Inflection object.\n     * @param {string} stem - A stem of a word.\n     * @param {string} language - A word's language.\n     */\n  constructor (stem, language) {\n    if (!stem) {\n      throw new Error('Stem should not be empty.')\n    }\n\n    if (!language) {\n      throw new Error('Langauge should not be empty.')\n    }\n\n    if (!LanguageModelFactory.supportsLanguage(language)) {\n      throw new Error(`language ${language} not supported.`)\n    }\n\n    this.stem = stem\n    this.language = language\n\n    // Suffix may not be present in every word. If missing, it will set to null.\n    this.suffix = null\n\n    // Prefix may not be present in every word. If missing, it will set to null.\n    this.prefix = null\n\n    // Example may not be provided\n    this.example = null\n  }\n\n  static readObject (jsonObject) {\n    let inflection = new Inflection(jsonObject.stem, jsonObject.language)\n    if (jsonObject.suffix) {\n      inflection.suffix = jsonObject.suffix\n    }\n    if (jsonObject.prefix) {\n      inflection.prefix = jsonObject.prefix\n    }\n    if (jsonObject.example) {\n      inflection.example = jsonObject.example\n    }\n    return inflection\n  }\n\n    /**\n     * Sets a grammatical feature in an inflection. Some features can have multiple values, In this case\n     * an array of Feature objects will be provided.\n     * Values are taken from features and stored in a 'feature.type' property as an array of values.\n     * @param {Feature | Feature[]} data\n     */\n  set feature (data) {\n    if (!data) {\n      throw new Error('Inflection feature data cannot be empty.')\n    }\n    if (!Array.isArray(data)) {\n      data = [data]\n    }\n\n    let type = data[0].type\n    this[type] = []\n    for (let element of data) {\n      if (!(element instanceof Feature)) {\n        throw new Error('Inflection feature data must be a Feature object.')\n      }\n\n      if (element.language !== this.language) {\n        throw new Error('Language \"' + element.language + '\" of a feature does not match a language \"' +\n                this.language + '\" of an Inflection object.')\n      }\n\n      this[type].push(element.value)\n    }\n  }\n}\nexport default Inflection\n","import Lemma from './lemma.js'\nimport Inflection from './inflection.js'\n\n/**\n * A basic unit of lexical meaning. Contains a Lemma object and one or more Inflection objects.\n */\nclass Lexeme {\n    /**\n     * Initializes a Lexeme object.\n     * @param {Lemma} lemma - A lemma object.\n     * @param {Inflection[]} inflections - An array of inflections.\n     * @param {string} meaning - a short definition\n     */\n  constructor (lemma, inflections, meaning = '') {\n    if (!lemma) {\n      throw new Error('Lemma should not be empty.')\n    }\n\n    if (!(lemma instanceof Lemma)) {\n      throw new Error('Lemma should be of Lemma object type.')\n    }\n\n    if (!inflections) {\n      throw new Error('Inflections data should not be empty.')\n    }\n\n    if (!Array.isArray(inflections)) {\n      throw new Error('Inflection data should be provided in an array.')\n    }\n\n    for (let inflection of inflections) {\n      if (!(inflection instanceof Inflection)) {\n        throw new Error('All inflection data should be of Inflection object type.')\n      }\n    }\n\n    this.lemma = lemma\n    this.inflections = inflections\n    this.meaning = meaning\n  }\n\n  static readObject (jsonObject) {\n    let lemma = Lemma.readObject(jsonObject.lemma)\n    let inflections = []\n    for (let inflection of jsonObject.inflections) {\n      inflections.push(Inflection.readObject(inflection))\n    }\n    return new Lexeme(lemma, inflections)\n  }\n}\nexport default Lexeme\n","import Lexeme from './lexeme.js'\n\nclass Homonym {\n    /**\n     * Initializes a Homonym object.\n     * @param {Lexeme[]} lexemes - An array of Lexeme objects.\n     * @param {string} form - the form which produces the homonyms\n     */\n  constructor (lexemes, form) {\n    if (!lexemes) {\n      throw new Error('Lexemes data should not be empty.')\n    }\n\n    if (!Array.isArray(lexemes)) {\n      throw new Error('Lexeme data should be provided in an array.')\n    }\n\n    for (let lexeme of lexemes) {\n      if (!(lexeme instanceof Lexeme)) {\n        throw new Error('All lexeme data should be of Lexeme object type.')\n      }\n    }\n\n    this.lexemes = lexemes\n    this.targetWord = form\n  }\n\n  static readObject (jsonObject) {\n    let lexemes = []\n    if (jsonObject.lexemes) {\n      for (let lexeme of jsonObject.lexemes) {\n        lexemes.push(Lexeme.readObject(lexeme))\n      }\n    }\n    let homonym = new Homonym(lexemes)\n    if (jsonObject.targetWord) {\n      homonym.targetWord = jsonObject.targetWord\n    }\n    return homonym\n  }\n\n    /**\n     * Returns language of a homonym.\n     * Homonym does not have a language property, only lemmas and inflections do. We assume that all lemmas\n     * and inflections within the same homonym will have the same language, and we can determine a language\n     * by using language property of the first lemma. We chan change this logic in the future if we'll need to.\n     * @returns {string} A language code, as defined in the `languages` object.\n     */\n  get language () {\n    if (this.lexemes && this.lexemes[0] && this.lexemes[0].lemma && this.lexemes[0].lemma.language) {\n      return this.lexemes[0].lemma.language\n    } else {\n      throw new Error('Homonym has not been initialized properly. Unable to obtain language information.')\n    }\n  }\n}\nexport default Homonym\n","/*\nObjects of a morphology analyzer's library\n */\nimport * as Models from 'alpheios-data-models'\n\n/**\n * Holds all information required to transform from morphological analyzer's grammatical feature values to the\n * library standards. There is one ImportData object per language.\n */\nclass ImportData {\n    /**\n     * Creates an InmportData object for the language provided.\n     * @param {Models.LanguageModel} language - A language of the import data.\n     */\n  constructor (language, engine) {\n    'use strict'\n    this.language = language\n    this.engine = engine\n    // add all the features that the language supports so that we\n    // can return the default values if we don't need to import a mapping\n    for (let featureName of Object.keys(language.features)) {\n      this.addFeature(featureName)\n    }\n  }\n\n    /**\n     * Adds a grammatical feature whose values to be mapped.\n     * @param {string} featureName - A name of a grammatical feature (i.e. declension, number, etc.)\n     * @return {Object} An object that represent a newly created grammatical feature.\n     */\n  addFeature (featureName) {\n    this[featureName] = {}\n    let language = this.language\n\n    this[featureName].add = function add (providerValue, alpheiosValue) {\n      'use strict'\n      this[providerValue] = alpheiosValue\n      return this\n    }\n\n    this[featureName].get = function get (providerValue) {\n      'use strict'\n      if (!this.importer.has(providerValue)) {\n        // if the providerValue matches the model value return that\n        if (language.features[featureName][providerValue]) {\n          return language.features[featureName][providerValue]\n        } else {\n          throw new Error(\"Skipping an unknown value '\" +\n                    providerValue + \"' of a grammatical feature '\" + featureName + \"' of \" + language + ' language.')\n        }\n      } else {\n        return this.importer.get(providerValue)\n      }\n    }\n\n    this[featureName].importer = new Models.FeatureImporter()\n\n    return this[featureName]\n  }\n}\nexport default ImportData\n","import ImportData from '../lib'\nimport * as Models from 'alpheios-data-models'\n\nlet data = new ImportData(new Models.LatinLanguageModel(), 'whitakerLat')\nlet types = Models.Feature.types\n\n/*\nBelow are value conversion maps for each grammatical feature to be parsed.\nFormat:\ndata.addFeature(typeName).add(providerValueName, LibValueName);\n(functions are chainable)\nTypes and values that are unknown (undefined) will be skipped during parsing.\n */\n\n // TODO  - per inflections.xsd\n // Whitakers Words uses packon and tackon in POFS, not sure how\n\ndata.addFeature(Models.Feature.types.gender).importer\n    .map('common',\n  [ data.language.features[types.gender][Models.Constants.GEND_MASCULINE],\n    data.language.features[types.gender][Models.Constants.GEND_FEMININE]\n  ])\n    .map('all',\n  [ data.language.features[types.gender][Models.Constants.GEND_MASCULINE],\n    data.language.features[types.gender][Models.Constants.GEND_FEMININE],\n    data.language.features[types.gender][Models.Constants.GEND_NEUTER]\n  ])\n\ndata.addFeature(Models.Feature.types.tense).importer\n    .map('future_perfect', data.language.features[types.tense][Models.Constants.TENSE_FUTURE_PERFECT])\n\nexport default data\n","import ImportData from '../lib'\nimport * as Models from 'alpheios-data-models'\n\nlet data = new ImportData(new Models.GreekLanguageModel(), 'morpheusgrc')\nlet types = Models.Feature.types\n\n/*\nBelow are value conversion maps for each grammatical feature to be parsed.\nFormat:\ndata.addFeature(typeName).add(providerValueName, LibValueName);\n(functions are chainable)\nTypes and values that are unknown (undefined) will be skipped during parsing.\n */\n\ndata.addFeature(Models.Feature.types.gender).importer\n    .map('masculine feminine',\n  [ data.language.features[types.gender][Models.Constants.GEND_MASCULINE],\n    data.language.features[types.gender][Models.Constants.GEND_FEMININE]\n  ])\n\ndata.addFeature(Models.Feature.types.declension).importer\n    .map('1st & 2nd',\n  [ data.language.features[types.declension][Models.Constants.ORD_1ST],\n    data.language.features[types.declension][Models.Constants.ORD_2ND]\n  ])\n\nexport default data\n","import ImportData from '../lib'\nimport * as Models from 'alpheios-data-models'\n\nlet data = new ImportData(new Models.ArabicLanguageModel(), 'aramorph')\nlet types = Models.Feature.types\n\ndata.addFeature(Models.Feature.types.part).importer\n    .map('proper noun', [data.language.features[types.part][Models.Constants.POFS_NOUN]])\n\nexport default data\n","import Cupidinibus from './latin_noun_cupidinibus.json'\nimport Mare from './latin_noun_adj_mare.json'\nimport Cepit from './latin_verb_cepit.json'\nimport Pilsopo from './greek_noun_pilsopo.json'\n\nclass WordTestData {\n  constructor () {\n    this._words = {\n      'cupidinibus': Cupidinibus,\n      'mare': Mare,\n      'cepit': Cepit,\n      'φιλόσοφος': Pilsopo\n    }\n  }\n\n  get (word) {\n    if (this._words.hasOwnProperty(word)) {\n      return this._words[word]\n    }\n    throw new Error(`Word \"${word}\" does not exist in test data`)\n  }\n}\nexport default WordTestData\n","import BaseAdapter from 'alpheios-morph-client'\nimport Whitakers from './lib/engine/whitakers'\nimport Morpheusgrc from './lib/engine/morpheusgrc'\nimport Aramorph from './lib/engine/aramorph'\nimport * as Models from 'alpheios-data-models'\nimport WordTestData from './lib/engine/data/test-data'\n\nclass TuftsAdapter extends BaseAdapter {\n  /**\n   * A Morph Client Adapter for the Tufts Morphology Service\n   * @constructor\n   * @param {object} engine an object which maps language code to desired engine code\n                            for that language. E.g. { lat : whitakerLat, grc: morpheusgrc }\n   */\n  constructor ({engine = null, url = null}) {\n    super()\n    this.langToEngine = engine\n    this.url = url\n    this.engineMap = new Map(([ Whitakers, Morpheusgrc, Aramorph ]).map((e) => { return [ e.engine, e ] }))\n    return this\n  }\n\n  getEngineLanguageMap (lang) {\n    return this.engineMap.get(this.langToEngine[lang])\n  }\n\n  prepareRequestUrl (lang, word) {\n    let engine = this.langToEngine[lang]\n    let url = this.url.replace('r_WORD', word).replace('r_ENGINE', engine).replace('r_LANG', lang)\n    return url\n  }\n\n  fetchTestData (lang, word) {\n    return new Promise((resolve, reject) => {\n      try {\n        let wordData = new WordTestData().get(word)\n        console.log(wordData)\n        let json = JSON.parse(wordData)\n        resolve(json)\n      } catch (error) {\n                // Word is not found in test data\n        reject(error)\n      }\n    })\n  }\n\n  /**\n   * A function that maps a morphological service's specific data types and values into an inflection library standard.\n   * @param {object} jsonObj - A JSON data from a Morphological Analyzer.\n   * @param {object} targetWord - the target of the analysis\n   * @returns {Homonym} A library standard Homonym object.\n   */\n  transform (jsonObj, targetWord) {\n    'use strict'\n    let lexemes = []\n    let annotationBody = jsonObj.RDF.Annotation.Body\n    if (!Array.isArray(annotationBody)) {\n            /*\n            If only one lexeme is returned, Annotation Body will not be an array but rather a single object.\n            Let's convert it to an array so we can work with it in the same way no matter what format it is.\n             */\n      annotationBody = [annotationBody]\n    }\n    for (let lexeme of annotationBody) {\n            // Get importer based on the language\n      let language = lexeme.rest.entry.dict.hdwd.lang\n      let mappingData = this.getEngineLanguageMap(language)\n      let lemma = new Models.Lemma(lexeme.rest.entry.dict.hdwd.$, language)\n      let meaning = lexeme.rest.entry.mean ? lexeme.rest.entry.mean.$ : ''\n\n      let inflections = []\n      let inflectionsJSON = lexeme.rest.entry.infl\n      if (!Array.isArray(inflectionsJSON)) {\n                // If only one inflection returned, it is a single object, not an array of objects. Convert it to an array for uniformity.\n        inflectionsJSON = [inflectionsJSON]\n      }\n      for (let inflectionJSON of inflectionsJSON) {\n        let inflection = new Models.Inflection(inflectionJSON.term.stem.$, mappingData.language.toCode())\n        if (inflectionJSON.term.suff) {\n                    // Set suffix if provided by a morphological analyzer\n          inflection.suffix = inflectionJSON.term.suff.$\n        }\n\n        if (inflectionJSON.xmpl) {\n          inflection.example = inflectionJSON.xmpl.$\n        }\n                // Parse whatever grammatical features we're interested in\n        if (inflectionJSON.pofs) {\n          inflection.feature = mappingData[Models.Feature.types.part].get(inflectionJSON.pofs.$)\n        }\n\n        if (inflectionJSON.case) {\n          inflection.feature = mappingData[Models.Feature.types.grmCase].get(inflectionJSON.case.$)\n        }\n\n        if (inflectionJSON.decl) {\n          inflection.feature = mappingData[Models.Feature.types.declension].get(inflectionJSON.decl.$)\n        }\n\n        if (inflectionJSON.num) {\n          inflection.feature = mappingData[Models.Feature.types.number].get(inflectionJSON.num.$)\n        }\n\n        if (inflectionJSON.gend) {\n          inflection.feature = mappingData[Models.Feature.types.gender].get(inflectionJSON.gend.$)\n        }\n\n        if (inflectionJSON.conj) {\n          inflection.feature = mappingData[Models.Feature.types.conjugation].get(inflectionJSON.conj.$)\n        }\n\n        if (inflectionJSON.tense) {\n          inflection.feature = mappingData[Models.Feature.types.tense].get(inflectionJSON.tense.$)\n        }\n\n        if (inflectionJSON.voice) {\n          inflection.feature = mappingData[Models.Feature.types.voice].get(inflectionJSON.voice.$)\n        }\n\n        if (inflectionJSON.mood) {\n          inflection.feature = mappingData[Models.Feature.types.mood].get(inflectionJSON.mood.$)\n        }\n\n        if (inflectionJSON.pers) {\n          inflection.feature = mappingData[Models.Feature.types.person].get(inflectionJSON.pers.$)\n        }\n\n        inflections.push(inflection)\n      }\n      lexemes.push(new Models.Lexeme(lemma, inflections, meaning))\n    }\n    return new Models.Homonym(lexemes, targetWord)\n  }\n\n  async getHomonym (lang, word) {\n    let jsonObj = await this.fetch(lang, word)\n    if (jsonObj) {\n      let homonym = this.transform(jsonObj, word)\n      return homonym\n    } else {\n        // No data found for this word\n      return undefined\n    }\n  }\n}\n\nexport default TuftsAdapter\n"],"names":["Constants.LANG_DIR_LTR","Constants.LANG_UNIT_WORD","Constants.POFS_ADVERB","Constants.POFS_ADVERBIAL","Constants.POFS_ADJECTIVE","Constants.POFS_ARTICLE","Constants.POFS_CONJUNCTION","Constants.POFS_EXCLAMATION","Constants.POFS_INTERJECTION","Constants.POFS_NOUN","Constants.POFS_NUMERAL","Constants.POFS_PARTICLE","Constants.POFS_PREFIX","Constants.POFS_PREPOSITION","Constants.POFS_PRONOUN","Constants.POFS_SUFFIX","Constants.POFS_SUPINE","Constants.POFS_VERB","Constants.POFS_VERB_PARTICIPLE","Constants.GEND_MASCULINE","Constants.GEND_FEMININE","Constants.GEND_NEUTER","Constants.TYPE_REGULAR","Constants.TYPE_IRREGULAR","Constants.ORD_1ST","Constants.ORD_2ND","Constants.ORD_3RD","Constants.LANG_LATIN","Constants.STR_LANG_CODE_LA","Constants.STR_LANG_CODE_LAT","Constants.NUM_SINGULAR","Constants.NUM_PLURAL","Constants.CASE_NOMINATIVE","Constants.CASE_GENITIVE","Constants.CASE_DATIVE","Constants.CASE_ACCUSATIVE","Constants.CASE_ABLATIVE","Constants.CASE_LOCATIVE","Constants.CASE_VOCATIVE","Constants.ORD_4TH","Constants.ORD_5TH","Constants.TENSE_PRESENT","Constants.TENSE_IMPERFECT","Constants.TENSE_FUTURE","Constants.TENSE_PERFECT","Constants.TENSE_PLUPERFECT","Constants.TENSE_FUTURE_PERFECT","Constants.VOICE_PASSIVE","Constants.VOICE_ACTIVE","Constants.MOOD_INDICATIVE","Constants.MOOD_SUBJUNCTIVE","Constants.LANG_GREEK","Constants.STR_LANG_CODE_GRC","Constants.NUM_DUAL","Constants.TENSE_AORIST","Constants.VOICE_MEDIOPASSIVE","Constants.VOICE_MIDDLE","Constants.MOOD_OPTATIVE","Constants.MOOD_IMPERATIVE","Constants.LANG_ARABIC","Constants.LANG_DIR_RTL","Constants.STR_LANG_CODE_ARA","Constants.STR_LANG_CODE_AR","Models.FeatureImporter","Models.LatinLanguageModel","Models.Feature","Models.Constants.GEND_MASCULINE","Models.Constants.GEND_FEMININE","Models.Constants.GEND_NEUTER","Models.Constants.TENSE_FUTURE_PERFECT","data","Models.GreekLanguageModel","types","Models.Constants.ORD_1ST","Models.Constants.ORD_2ND","Models.ArabicLanguageModel","Models.Constants.POFS_NOUN","Whitakers","Morpheusgrc","Aramorph","Models.Lemma","Models.Inflection","Models.Lexeme","Models.Homonym"],"mappings":"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"}